Action                 | Possible error      | Result
1) Compilation         | Syntax              | IR bytecode (instructions with references to known data only)
                       |                     | Reference record
                       |                     | Global data (const only?)
                       |                     | 
2) Resolve References  | Undefined reference | IR bytecode (instruction with references to all data)
                       | Invalid arg count   | Global data (const and global variables)
                       |                     | 
3) Translate & Execute | Runtime             | Program's output


Data structures for 1): 
IR program: [left] -- IR Bytecode stack    --> ... <-- Reference record/stack                    -- [right]
IR data:    [left] -- Typecheck/eval stack --> ... <-- Local variables|Runtime/Translation stack -- [right]
Local variables: lives to the right of IR data stack. WILL BE OVERWRITTEN in 3)
Global variables/functions: lives in a dedicated Global hash table
Reference record: 
  function: 
      name, line, offset 
      referenced location
      return type 
      argument count at call site
  variable: 
      name, line, offset
      referenced location
      type 
      scope (if referenced was done in a scope)


Data structures for 2):
Use 1)'s reference stack, pop check element and resolve their references until the stack is empty
For global references: look in the Global hash table
    local references : look in the Local variable stack 


Data structures for 3):
Runtime/Translation stack (reuses Local variable stack since it has served its purpose in 1) and 2))




            


